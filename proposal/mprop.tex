\documentclass{mprop}
\usepackage{graphicx}

% alternative font if you prefer
%\usepackage{times}

% for alternative page numbering use the following package
% and see documentation for commands
%\usepackage{fancyheadings}


% other potentially useful packages
%\uspackage{amssymb,amsmath}
%\usepackage{url}
%\usepackage{fancyvrb}
%\usepackage[final]{pdfpages}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{Extending QUIC to Support RTP}
\author{Vivian Band}
\date{\today}
\maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}\label{intro}

%briefly explain the context of the project problem

Transport protocols are an essential component of networked communications; they determine a 
number of important characteristics of traffic sent over IP, such as reliability, timeliness, and 
aggression. Ossification of the wider Internet has been enforced by middleboxes interfering with 
unrecognised traffic types, leading to the two most widespread options being the two transport 
protocols which were standardised the earliest: UDP and TCP. 

UDP's lightweight design was originally intended to allow unreliable, low-latency communication, 
however, this property has benefits which have become increasingly notable in recent years: the 
lack of in-built behaviours as a result of reliability guarantees, combined with widespread 
acceptance by middleboxes, makes UDP an appealing blank canvas for engineers to use as a base for 
constructing flexible and widely deployable new userspace transport protocols.

QUIC is a userspace transport protocol currently being developed by Google and the IETF as an 
alternative to TCP. QUIC has three distinct advantages over most implementations of TCP: it is 
much easier to deploy and modify as a result of not requiring kernel modifications; both payload 
content and the majority of header fields are encrypted by default; and it uses multiplexed 
streams to avoid problems with head-of-line blocking. The protocol is still in the design stage, 
with the majority of development focuses on the use-case of client-server applications with 
ordered content and relaxed latency bounds.

In this project, I aim to show that QUIC can be adapted for a significantly different use-case: 
streaming interactive media using RTP over QUIC. This version will improve on similar previous 
work, implementing deadline and dependency awareness in addition to selective restransmissions 
rather than solely discriminating based on media frame type (ie. I-frame, B-frame, P-frame) \cite
{Palmer2018}.

%%%%%DISCARDED FRAGMENT, MIGHT BE USEFUL LATER%%%%%
%TCP has received much refinement in the 37 years since its initial standardisation, however, it 
%is becoming increasingly difficult to deploy the kernel-level changes needed for new 
%optimisations to take effect as the number of machines on the Internet continues to increase. 
%For example, TCP Fast-Open, a modification standardised in December 2014, is still not deployed 
%in a majority of Internet-connected devices as of early 2018 \cite{tfo-failures}.

%%%%%OLDER DRAFT%%%%%

%QUIC is a transport protocol currently being developed by Google and the IETF as an alternative 
%to TCP, focusing on userspace development rather than kernel modifications to allow widespread 
%deployment and for ease of changing protocol behaviours. QUIC is reported to serve up to 9.1\% 
%of Internet traffic as of 2018, with 98\% of this being generated by Google services 
%\cite{Ruth2018}. 

%A key feature of QUIC traffic is that both payload content and the majority of header fields are 
%encrypted by default using TLS 1.3. QUIC's focus on encrypted traffic as standard for increased %
%security is likely to contribute towards an increased use of the protocol, combined with backing 
%from influential technology companies and the ease of deploying userspace protocols.

%Dynamic Adaptive Streaming over HTTP (DASH) is widely used by online streaming services such as 
%Netflix to deliver multimedia content, but this approach encounters problems with stalling due 
%to head-of-line blocking in TCP. QUIC mitigates this issue by using several streams 
%demultiplexed over a single UDP socket; although head-of-line blocking still occurs in response 
%to loss, the obstruction is confined to a single stream rather than blocking the entire 
%connection. With some adjustments to optimisation algorithms used in DASH, QUIC could be used to 
%provide higher quality streaming services for unidirectional content \cite{Bhat2017}.

%Interactive media is commonly streamed using the Real-time Transport Protocol (RTP) over UDP. 
%Applications using RTP prioritise low latency over reliability: the end-user experience of VoIP 
%sessions and multiplayer games, for example, is significantly impacted by even minor delays in 
%data reaching the application, but a small amount of packet loss may not be noticeable.

%Although more complicated than DASH, where media is delivered as a series of \texttt{HTTP GET} 
%requests, RTP allows applications to customise how data should be formatted and transferred 
%between participants through the use of RTP profiles \cite{RTP-RFC}. This flexibility allows RTP 
%to be used for a wide range of interactive applications, including technologies which have only 
%started becoming widespread in recent years like AR and VR. QUIC's behaviours are similarly 
%malleable due to not requiring any kernel modifications - while guaranteed reliability is not 
%desirable for low-latency applications, an extension to QUIC which introduces partial 
%reliability alongside existing stream demultiplexing capabilities, framing, and increased 
%security could be highly desirable for interactive media.

The remainder of this report consists of the following sections:

\begin{itemize}
	\item \textbf{Section 2: Statement of Problem} explains the motivations for extending QUIC to 
	run RTP.
	\item \textbf{Section 3: Key Differences Between Underlying Transport Protocols for RTP} 
	details the key functional and semantic incompatibilities between stream-based transport 
	protocols and RTP.
	\item \textbf{Section 4: Literature Survey} explores previous attempts at running RTP over a 
	stream-based transport protocol.
	\item \textbf{Section 5: Proposed Approach} describes the deliverables of this project, how 
	they relate to the aims outlined in section 2, and the processes used to create them.
	\item \textbf{Section 6: Work Plan} provides a proposed schedule for the deliverables outlined 
	in section 5.
\end{itemize}

%\subsection{A subsection}
%Please note your proposal need not follow the included section headings - this is only a suggested structure. Also add subsections etc as required

%example references: \cite{BK08}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Statement of Problem}

%clearly state the problem to be addressed in your forthcoming project. Explain why it would be worthwhile to solve this problem.

QUIC is reported to serve up to 9.1\% of Internet traffic as of 2018, with 98\% of this being generated by Google services \cite {Ruth2018}. The IETF is still in the process of standardising the first version of the protocol, with the involvement of engineers from various high-profile technology companies, however, development is currently focused on client-server applications with relaxed latency bounds.

QUIC's best-effort loss recovery makes it a poor choice as a transport for interactive applications using RTP traffic, but the defining strength of userspace protocols is their flexibility: running RTP over a modified version of the QUIC protocol which uses selective restransmissions and has awareness of deadlines could potentially outperform RTP over UDP in terms of quality of experience, as well as providing greater security through use of encrypted traffic. This project aims to create a set of extensions which allow QUIC endpoints to use partial reliability for interactive applications, most likely through sending transport parameters during initial connection setup.

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Key Differences Between Underlying Transport Protocols for RTP}

\subsection{Differences in Reliability and Latency}

Best-effort transport protocols like TCP and QUIC are not optimal choices for streaming interactive media due to prioritising reliability over timeliness. Guaranteed reliability is useful for applications with relaxed latency bounds and strict ordering requirements (eg. serving static web pages), but head-of-line blocking in response to packet loss impairs the performance of time-sensitive, interactive applications typically using RTP. This effect is noticeable even when the delay is confined to a single stream within a QUIC connection as it risks breaking synchronisation between different media channels (eg. mismatch between audio and video).

RTP over UDP typically achieves low-latency by not attempting to recover lost packets, opting to use feedback from RTCP sender and receiver reports to change the quality of media generated by the codec if a session experiences significant loss. However, a dropped packet could still be useful to the application, provided it can be retransmitted by the sender and processed by the receiver before the playback deadline. This functionality is known as partial reliability, which consists of selectively retransmitting frames that are deemed to meet the playback deadline under current network conditions, and dropping frames which exceed it. At least one of the transport protocols used needs to have deadline awareness, which requires a moving average of RTTs, current playback position, and timestamps of recently lost frames. This behaviour could be implemented within an intermediary layer or within the QUIC protocol.

Dependencies between frames also need to be considered: P-frames change visual information relative to a previously sent I-frame, so a `stale' I-frame which will not arrive at the application before the playback deadline may still need to be retransmitted to allow useful P-frames to work. Either QUIC or an intermediary layer needs to be aware of which QUIC packets contain specific I-frames and which P-frames rely on them for this behaviour to work. This is complicated further by the possibility that multiple QUIC packets may be required to accomodate a single I-frame, depending on the maximum packet size allowed.

A retransmission scheme for RTP has already been published as RFC 4588 \cite{RTP-retransmission-RFC}. While this document acknowledges the challenges of implementing deadline awareness, it also assumes that RTP will be running over UDP rather than a reliable, stream-oriented transport. Running RTP over QUIC does have the advantage of not needing to re-implement base acknowledgement and retransmission functions from scratch, but the reliable retransmission and buffering behaviours within QUIC will need modification for selective retransmission and deadline awareness to work. These alterations cannot be performed at an intermediary layer or within an RTP-based application, and will add more complexity to the QUIC specification.

\subsection{Semantic Differences}

Creating an RTP extension for QUIC is further complicated by a semantic mismatch between the two protocols: RTP uses datagrams to transmit frame data and timing information, usually sending a single RTP frame per datagram, while QUIC is a stream-based protocol which does not have distinct boundaries between items of data once they are removed from their QUIC payload frames. It is not possible to guarantee a complete frame will be extracted from the stream due to not knowing its exact length - retrieving and parsing segments of arbitrary size to determine if one or more complete frames are present would add needless complexity to an RTP-QUIC extension, especially since a new parser would need to be written for each codec type. A custom QUIC payload frame type which contains a length field could resolve this issue.

Another important distinction between UDP and QUIC is the maximum payload size: datagrams in UDP have a maximum payload of 65527 bytes, but an endpoint using QUIC over an IP link will aim to have a QUIC packet size between 1472 and 1200 bytes to avoid fragmentation at the IP layer \cite{quic-transport-16}. While P-frames and B-frames in video can be transmitted within this limit without fragmentation, I-frames are typically much larger and will need to be sent in multiple QUIC payloads if packet size is restricted. These will either need to be reassembled within QUIC and passed to the application as a single, complete frame; reassembled within the application itself; or reassembled within an intermediary layer.

While the first option makes the extension easier to use for developers of applications using RTP, it does also add complexity to an already extensive specification, requiring QUIC developers to add even more features to their implementations of the protocol. The second option minimises the changes required to QUIC, but requires additional effort from developers working with real-time applications. The third option of offering a pre-built intermediary layer to handle RTP frame reassembly and error correction is a minimally invasive compromise for both parties, requiring no significant additions to QUIC and placing fewer technical demands on developers who wish to use the extensions, however, QUIC and the application using the extension have no requirement to validate that this layer is active on both endpoints. Similar considerations need to be made with regards to error correction for RTP frames: error correction and reassembly do not have to take place in the same locations, but it would likely be more sensible to do error correction after reassembly since flaws could be missed while fragments are separated.

The disparities between RTP and QUIC in terms of semantics and reliability make creating an RTP extension to the protocol challenging. However, the flexibility of QUIC as a userspace protocol allows significant changes to its underlying loss recovery and stream buffering behaviours, meaning that it is possible to build a variant of QUIC suited to interactive media through use of selective retransmissions and custom payload frame types.


\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Literature Survey}

%present an overview of relevant previous work including articles, books, and existing software products. Critically evaluate the strengths and weaknesses of the previous work.

NOTE: this will be less list-like and more of a discussion in later drafts

\subsection{Proposed Adjustments to QUIC}

\begin{itemize}
	\item QUIC-R Extensions \cite{Perkins}: Outline for general idea of project, general discussion 
	rather than specifics
  
  \item ClipStream \cite{Palmer2018}: QUIC Fix for Optimal Video Streaming - only seems to deal 
  with DASH explicitly, not RTP. Streams are either completely reliable or completely unreliable, 
  decided based on type of frame being transmitted - doesn't seem to take deadlines into account

  \item Not so QUIC \cite{Bhat2017}: Focuses on adapting DASH for use with QUIC - finds a 
  degradation in performance, emphasises that QUIC is not a direct replacement for TCP. Could 
  potentially face similar issues in this project.
\end{itemize}

\subsection{Use of TCP for Streaming}

\begin{itemize}
  \item TCP Hollywood \cite{McQuistin2016}: Important for deadline awareness and evidence why 
  QUIC version is more easily deployable

  \item Real-Time Mode for TCP \cite{Liang2002}: Modifying TCP in 2002, finds that loss recovery 
  behaviours improve quality of real-time playback

  \item RFC 4571: RTP over TCP: issues with HoL blocking, doesn't have awareness of multiplexed 
  QUIC streams or QUIC frames

  \item RFC 4588: RTP Retransmission Payload Format: Details of a 2006 scheme used for 
  restransmitting RTP packets. Doesn't take semantic differences into account and designed for 
  applications with relaxed latency bounds.
\end{itemize}

\subsection{Userspace Transport Protocols}

\begin{itemize}
  \item Implementing Real-Time Transport Services over an Ossified Network 
  \cite {McQuistin2016Ossification}: Confirms the idea that UDP as a substrate for transport 
  protocols is viable and likely to gain further popularity. Provides statistics on how likely it 
  is that UDP traffic will be blocked by a given network.
\end{itemize}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Proposed Approach}

%state how you propose to solve the software development problem. Show that your proposed approach is feasible, but identify any risks.

Same as above: will be converted from a list into a discussion instead.

\begin{enumerate}
  \item Create a simple application in C which creates RTP packets (correctly formatted in terms 
  of headers, but not sending meaningful media content) and sends them to a remote peer. First 
  write this as a unidirectional application, then modify it to send data and RTCP info from both 
  participants simultaneously (Probably three threads: one for sending data and RTCP reports, one 
  polling the two sockets for new RTP data and RTCP feedback, and one processing received data 
  and reports)

  \item Modify the previous application to send correctly encoded media data (eg. Elephant's 
  Dream) using an arbitrarily chosen codec (probably H.264, since this was mentioned in the TCP 
  Hollywood paper)

  \item Change the underlying transport from UDP to QUIC using a single stream for all media 
  content and a separate stream for RTCP operations, all sent using generic DATA QUIC frames. The 
  performance will be terrible due to HoL blocking, but it will be a chance to become familiar 
  with the chosen QUIC implementation (likely ngtcp2 - draft-15 compliant, familiar language, and 
  client/server/library roles) (Will need to build a shim layer here to identify and mitigate 
  semantic differences between QUIC and RTP (eg. reassembling I-frames))

  \item Implement partial reliability by modifying loss recovery mechanisms within QUIC, again 
  testing on a minimal two-stream application (possibly unidirectional at first to simplify 
  debugging). Make sure this works by dropping (eg.) 10\% of QUIC packets and checking that 
  packets which are not received by participant B are no longer queued at participant A.

  \item Create deadline awareness using sequence numbers and an average of observed RTTs over a 
  given time period (eg. moving average over the past 20 trips). This will likely be in the shim 
  layer initially with a message of some sort being sent to QUIC to mark useful packets in some 
  way (or, alternatively, drop all queued packets with sequence number < [XYZ] from the buffer 
  which QUIC uses for holding retransmissions)

  \item Improve deadline awareness to take RTP frame dependencies into account: if an I-frame has 
  a sequence number which would cause it to be dropped from the buffer, check if there are P-
  frames with a sequence number >= [XYZ] - drop if no, keep if yes. Test this in a similar way to 
  (4), checking that packet traces and traces from within QUIC show these beahviours. (this will 
  require looking into QUIC payloads and detecting which kind of video frames are contained 
  within them - implementing new QUIC frames for I- and P-frames may make this process more 
  efficient)

  \item Create multiple QUIC streams for media and RTCP content. Start with creating a stream for 
  every video frame initially, keeping track of how many streams currently exist each time one is 
  created. Introduce a limit on the number of streams that can be created - start at the maximum 
  number of streams observed earlier, and decrement it by reasonable intervals for subsequent 
  tests.
\end{enumerate}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Work Plan}

%show how you plan to organize your work, identifying intermediate deliverables and dates.

Still need to consider this.

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% it is fine to change the bibliography style if you want
\bibliographystyle{plain}
\bibliography{mprop}
\end{document}
