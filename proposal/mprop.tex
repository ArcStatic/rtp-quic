\documentclass{mprop}
\usepackage{graphicx}

% alternative font if you prefer
%\usepackage{times}

% for alternative page numbering use the following package
% and see documentation for commands
%\usepackage{fancyheadings}


% other potentially useful packages
%\uspackage{amssymb,amsmath}
%\usepackage{url}
%\usepackage{fancyvrb}
%\usepackage[final]{pdfpages}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{Extending QUIC to Support RTP}
\author{Vivian Band}
\date{\today}
\maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}\label{intro}

%briefly explain the context of the project problem

QUIC is a transport protocol currently being developed by Google and the IETF as an alterative to TCP, focusing on userspace development rather than kernel modifications to allow widespread deployment and for ease of changing protocol behaviours. QUIC is reported to serve up to 9.1\% of Internet traffic as of 2018, with 98\% of this being generated by Google services \cite{Ruth2018}. 

A key feature of QUIC traffic is that all content, including the majority of header fields, is encrypted by default using TLS 1.3. While there are questions over intentionally introduced vulnerabilities in this encryption scheme, QUIC's focus on encrypted traffic as standard for increased security is likely to contribute towards an increased use of the protocol, combined with backing from influential technology companies and the ease of deploying userspace protocols.

Dynamic Adaptive Streaming over HTTP (DASH) is widely used by online streaming services such as Netflix to deliver multimedia content, but this approach encounters problems with stalling due to head-of-line blocking in TCP. QUIC mitigates this issue by using several streams demultiplexed over a single UDP socket; although head-of-line blocking still occurs in response to loss, the obstruction is confined to a single stream rather than blocking the entire connection. With some adjustments to optimisation algorithms used in DASH, QUIC could be used to provide higher quality streaming services for unidirectional content \cite{Bhat2017}.

Interactive media is commonly streamed using the Real-time Transport Protocol (RTP) over UDP. Applications using RTP prioritise low latency over reliability: the end-user experience of VoIP sessions and multiplayer games, for example, is significantly impacted by even minor delays in data reaching the application, but a small amount of packet loss may not be noticeable.

Although more complicated than DASH, where media is delivered as a series of \texttt{HTTP GET} requests, RTP allows applications to customise how data should be formatted and transferred between participants through the use of RTP profiles \cite{RTP-RFC}. This flexibility allows RTP to be used for a wide range of interactive applications, including technologies which have only started becoming widespread in recent years like AR and VR. QUIC's behaviours are similarly malleable due to not requiring any kernel modifications - while guaranteed reliability is not desirable for low-latency applications, an extension to QUIC which introduces partial reliability alongside existing stream demultiplexing capabilities, framing, and increased security could be highly desirable for interactive media.

%\subsection{A subsection}
%Please note your proposal need not follow the included section headings - this is only a suggested structure. Also add subsections etc as required

%example references: \cite{BK08}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Statement of Problem}

%clearly state the problem to be addressed in your forthcoming project. Explain why it would be worthwhile to solve this problem.

Best-effort transport protocols like TCP and QUIC are not optimal choices for streaming interactive media due to prioritising reliability over timeliness. Guaranteed reliability is useful for applications with relaxed latency bounds and strict ordering requirements (eg. serving static web pages), but head-of-line blocking in response to packet loss impairs the performance of time-sensitive, interactive applications typically using RTP. This effect is noticeable even when the delay is confined to a single stream within a QUIC connection as it risks breaking synchronisation between different media channels (eg. mismatch between audio and video).

RTP over UDP typically achieves low-latency by not attempting to recover lost packets, opting to use feedback from RTCP sender and receiver reports to change the quality of media generated by the codec if a session experiences significant loss. However, a dropped packet could still be useful to the application, provided it can be retransmitted by the sender and processed by the receiver before the playback deadline. This functionality is known as partial reliability, which consists of selectively retransmitting frames that are deemed to meet the playback deadline under current network conditions, and dropping frames which exceed it. At least one of the transport protocols used needs to have deadline awareness, which requires a moving average of RTTs, current playback position, and timestamps of recently lost frames. This behaviour could be implemented within an intermediary layer or within the QUIC protocol.

Dependencies between frames also need to be considered: P-frames change visual information relative to a previously sent I-frame, so a `stale' I-frame which will not arrive at the application before the playback deadline may still need to be retransmitted to allow useful P-frames to work. Either QUIC or an intermediary layer needs to be aware of which QUIC packets contain specific I-frames and which P-frames rely on them for this behaviour to work. This is complicated further by the possibility that multiple QUIC packets may be required to accomodate a single I-frame, depending on the maximum packet size allowed.

A retransmission scheme for RTP has already been published as RFC 4588 \cite{RTP-retransmission-RFC}. While this document acknowledges the challenges of implementing deadline awareness, it also assumes that RTP will be running over UDP rather than a reliable, stream-oriented transport. Running RTP over QUIC does have the advantage of not needing to re-implement base acknowledgement and retransmission functions from scratch, but the reliable retransmission and buffering behaviours within QUIC will need modification for selective retransmission and deadline awareness to work. These alterations cannot be performed at an intermediary layer or within an RTP-based application, and will add more complexity to the QUIC specification.

[Write about RFC 4571, effort to run RTP over TCP - HoL blocking, doesn't have awareness of multiplexed QUIC streams or QUIC frames]

Creating an RTP extension for QUIC is further complicated by a semantic mismatch between the two protocols: RTP uses datagrams to transmit frame data and timing information, usually sending a single RTP frame per datagram, while QUIC is a stream-based protocol which does not have distinct boundaries between items of data once they are removed from their QUIC payload frames. It is not possible to guarantee a complete frame will be extracted from the stream due to not knowing its exact length - retrieving and parsing segments of arbitrary size to determine if one or more complete frames are present would add needless complexity to an RTP-QUIC extension, especially since a new parser would need to be written for each codec type. A custom QUIC payload frame type which contains a length field could resolve this issue.

Another important distinction between UDP and QUIC is the maximum payload size: datagrams in UDP have a maximum payload of 65527 bytes, but an endpoint using QUIC can use the transport parameter \texttt{max\_packet\_size} to limit accepted packet sizes down to a minimum of 1200 bytes \cite{quic-transport-16}. While P-frames and B-frames in video can be transmitted within this limit without fragmentation, I-frames are typically much larger and will need to be sent in multiple QUIC payloads if packet size is restricted. These will either need to be reassembled within QUIC and passed to the application as a single, complete frame; reassembled within the application itself; or reassembled within an intermediary layer.

[Note: above paragraph will need changes if QUIC packets are restricted to 1232/1252 bytes, but the ideas still apply if this is the case.]

% quic-transport-16 14.1:
%- "In the absence of these mechanisms [PMTU], QUIC endpoints SHOULD NOT send IP packets larger than 1280 octets"
%- "Assuming the minimum IP header size, this results in a QUIC packet size of 1232 octets for IPv6 and 1252 octets for IPv4"
% - "If a QUIC endpoint determines that the PMTU between any pair of local and remote IP addresses has fallen below 1280 octets, it MUST immediately cease sending QUIC packets on the affected path."

% Does this mean QUIC packets are restricted to 1232 for v6 and 1252 for v4? IP packets seem to be confined to exactly 1280 bytes.

% quic-transport-16 18.1:
%- "max_packet_size (0x0005):  The maximum packet size parameter places a limit on the size of packets that the endpoint is willing to receive, encoded as an unsigned 16-bit integer. 
% This indicates that packets larger than this limit will be dropped. The default for this parameter is the maximum permitted UDP payload of 65527. 
% Values below 1200 are invalid. This limit only applies to protected packets (Section 12.1)."

% How does this allow anything other than 1232 or 1252 bytes given the info in section 14.1?
% Could work if a huge QUIC packet is fragmented into 1280 byte IP packets and reassembled at the receiver within IP layer.
% Why are values below 1232/1252 allowed when section 14.1 says to cease sending QUIC packets if PMTU falls below 1280 (smallest possible IPv6 MTU)?
% Guessing not all space needs to be used in protected packets, but 1200 max limit could drop otherwise legal IPv6 packets.

While the first option makes the extension easier to use for developers of applications using RTP, it does also add complexity to an already extensive specification, requiring QUIC developers to add even more features to their implementations of the protocol. The second option minimises the changes required to QUIC, but requires additional effort from developers working with real-time applications. The third option of offering a pre-built intermediary layer to handle RTP frame reassembly and error correction is a minimally invasive compromise for both parties, requiring no significant additions to QUIC and placing fewer technical demands on developers who wish to use the extensions, however, QUIC and the application using the extension have no requirement to validate that this layer is active on both endpoints. Similar considerations need to be made with regards to error correction for RTP frames, but error correction and reassembly do not have to take place in the same locations. [But it probably makes more sense to do error correction after reassembly - flaws could be missed while fragments are separate]

The disparities between RTP and QUIC in terms of semantics and reliability make creating an RTP extension to the protocol challenging. However, the flexibility of QUIC as a userspace protocol allows significant changes to its underlying loss recovery and stream buffering behaviours, meaning that it is possible to build a variant of QUIC suited to interactive media through use of selective retransmissions and custom payload frame types. 



\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Background Survey}

present an overview of relevant previous work including articles, books, and existing software products. Critically evaluate the strengths and weaknesses of the previous work.

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Proposed Approach}

state how you propose to solve the software development problem. Show that your proposed approach is feasible, but identify any risks.

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Work Plan}

show how you plan to organize your work, identifying intermediate deliverables and dates.

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% it is fine to change the bibliography style if you want
\bibliographystyle{plain}
\bibliography{mprop}
\end{document}
