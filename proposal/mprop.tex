\documentclass{mprop}
\usepackage{graphicx}

% alternative font if you prefer
%\usepackage{times}

% for alternative page numbering use the following package
% and see documentation for commands
%\usepackage{fancyheadings}


% other potentially useful packages
%\uspackage{amssymb,amsmath}
%\usepackage{url}
%\usepackage{fancyvrb}
%\usepackage[final]{pdfpages}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{Extending QUIC to Support Real-Time Applications}
\author{Vivian Band}
\date{\today}
\maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}\label{intro}

%briefly explain the context of the project problem

Transport protocols are an essential component of networked communications; they determine a 
number of important characteristics of traffic sent over Internet Protocol (IP) \cite{IP-RFC}, 
such as reliability, timeliness, and aggression. Ossification of the wider Internet has been 
enforced by middleboxes interfering with unrecognised traffic types, leading to the two most 
widespread options being the two transport protocols which were standardised the earliest: User 
Datagram Protocol (UDP) \cite{UDP-RFC} and Transmission Control Protocol (TCP) \cite{TCP-RFC}. 

UDP's lightweight design was originally intended to allow unreliable, low-latency communication, 
however, this property has benefits which have become increasingly notable in recent years: the 
lack of in-built behaviours as a result of reliability guarantees, combined with widespread 
acceptance by middleboxes, makes UDP an appealing blank canvas for engineers to use as a base for 
constructing flexible and widely deployable new userspace transport protocols.

QUIC \cite{quic-transport-16} is a userspace transport protocol currently being developed by Google and the Internet Engineering Task Force (IETF) as an alternative to TCP. QUIC has three distinct advantages over most implementations of TCP: it is much easier to deploy and modify as a result of not requiring kernel modifications; both payload content and the majority of header fields are encrypted by default; and it uses multiplexed streams to avoid problems with head-of-line blocking. The protocol is still in the design stage, with the majority of development focused on the use-case of HTTP/2 \cite{HTTP2-RFC} web traffic with ordered content and relaxed latency bounds.

In this project, I aim to show that QUIC can be adapted for a significantly different use-case: 
real-time, interactive media using the Real-Time Transport Protocol (RTP) \cite{RTP-RFC} over 
QUIC. This version will improve on similar previous work, implementing deadline and dependency 
awareness in addition to selective restransmissions rather than solely discriminating based on 
media frame type (ie. I-frames, P-frames) \cite {Palmer2018}.

%%%%%DISCARDED FRAGMENT, MIGHT BE USEFUL LATER%%%%%
%TCP has received much refinement in the 37 years since its initial standardisation, however, it 
%is becoming increasingly difficult to deploy the kernel-level changes needed for new 
%optimisations to take effect as the number of machines on the Internet continues to increase. 
%For example, TCP Fast-Open, a modification standardised in December 2014, is still not deployed 
%in a majority of Internet-connected devices as of early 2018 \cite{tfo-failures}.

The remainder of this report consists of the following sections:

\begin{itemize}
	\item \textbf{Section 2: Statement of Problem} explains the motivations for extending QUIC to 
	run RTP.
	\item \textbf{Section 3: Key Differences Between Underlying Transport Protocols for RTP} 
	details the key functional and semantic incompatibilities between stream-based transport 
	protocols and RTP.
	\item \textbf{Section 4: Literature Survey} explores previous attempts at running RTP over a 
	stream-based transport protocol.
	\item \textbf{Section 5: Proposed Approach} describes the deliverables of this project, how 
	they relate to the aims outlined in section 2, and the processes used to create them.
	\item \textbf{Section 6: Work Plan} provides a proposed schedule for the deliverables outlined 
	in section 5.
\end{itemize}

%\subsection{A subsection}
%Please note your proposal need not follow the included section headings - this is only a suggested structure. Also add subsections etc as required

%example references: \cite{BK08}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Statement of Problem}

%clearly state the problem to be addressed in your forthcoming project. Explain why it would be worthwhile to solve this problem.

QUIC is reported to serve up to 9.1\% of Internet traffic as of 2018, with 98\% of this being 
generated by Google services \cite {Ruth2018}. The IETF is still in the process of standardising 
the first version of the protocol, with the involvement of engineers from various high-profile 
technology companies, however, development is currently focused on improving the performance of 
HTTP.

QUIC offers reliable delivery of ordered data, only delivering a stream of data to RTP 
applications when all packets up to the most recently received have been recovered and 
reassembled in the correct order. This behaviour results in increased latency and makes QUIC a 
poor choice as an underlying transport protocol for real-time, interactive applications like 
Voice over IP (VoIP) or multiplayer gaming, especially given that these applications are more 
adversely affected by high-latency than by packet loss. UDP is the typical choice of transport 
for real-time applications, delivering datagrams containing RTP packets to an RTP application as 
they are received without any reliability or ordering guarantees. This behaviour minimises 
latency at the expense of occasional packet loss and out-of-order delivery, a balance which 
generally provides the best quality of experience for real-time applications.

However, the defining strength of userspace protocols is their flexibility: a version of QUIC 
which uses selective restransmissions and has awareness of deadlines could potentially outperform 
UDP in terms of quality of experience for real-time applications, as well as providing greater 
security through use of encrypted traffic. This project aims to create a set of extensions which 
allow QUIC endpoints to use partial reliability for interactive, real-time applications, most 
likely through sending transport parameters during initial connection setup.

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Key Differences Between Underlying Transport Protocols for RTP}

A key feature of QUIC traffic is that all content, including the majority of header fields, is 
encrypted by default using TLS 1.3 \cite{quic-transport-16}. QUIC's focus on encrypted traffic as 
standard for increased security is likely to contribute towards an increased use of the protocol, 
combined with backing from influential technology companies and the ease of deploying userspace 
protocols.

Dynamic Adaptive Streaming over HTTP (DASH) is widely used by online streaming services like 
Netflix to deliver multimedia content, but this approach encounters problems with stalling due to 
head-of-line blocking in TCP; QUIC mitigates this issue by using several streams demultiplexed 
over a single UDP socket. Although head-of-line blocking still occurs in response to loss, the 
obstruction is confined to a single stream rather than blocking the entire connection. With some 
adjustments to optimisation algorithms used in DASH, QUIC could be used to provide higher quality 
streaming services for unidirectional media content \cite{Bhat2017}.

Real-time media is commonly streamed using RTP over UDP. Applications using RTP prioritise low 
latency over reliability; the end-user experience of VoIP sessions and multiplayer games, for 
example, is significantly impacted by even minor delays in data reaching the application, but a 
small amount of packet loss can be concealed and out-of-order delivery can occasionally be 
corrected within RTP.

Although more complicated than DASH, where media is delivered as a series of \texttt{HTTP GET} 
requests, RTP allows applications to customise how data should be formatted and transferred 
between participants through the use of RTP profiles \cite{RTP-RFC}. This flexibility allows RTP 
to be used for a wide range of applications, including technologies which have only started 
becoming widespread in recent years like AR and VR. QUIC's behaviours are similarly malleable due 
to not requiring any kernel modifications: while guaranteed reliability is not desirable for real-
time applications, an extension to QUIC which introduces partial reliability alongside existing 
stream demultiplexing capabilities, framing, and increased security could be highly desirable for 
real-time, interactive media.

\subsection{Differences in Reliability and Latency}

Reliable transport protocols like TCP and QUIC are not optimal choices for real-time, interactive 
applications like VoIP due to prioritising reliability over timeliness. Guaranteed reliability is 
useful for applications with relaxed latency bounds and strict ordering requirements (eg. serving 
web pages), but head-of-line blocking in response to packet loss impairs the performance of time-sensitive applications typically using RTP. This effect is noticeable even when the delay is confined to a single stream within a QUIC connection as it risks breaking synchronisation between different media channels (eg. mismatch between audio and video).

RTP over UDP typically achieves low-latency by not attempting to recover lost packets, opting to use feedback from RTCP sender and receiver reports to change the quality of media generated by the codec if a session experiences significant loss. However, a dropped packet could still be useful to the application, provided it can be retransmitted by the sender and processed by the receiver before the playback deadline. This functionality is known as partial reliability, which consists of selectively retransmitting frames that are deemed to meet the playback deadline under current network conditions, and dropping frames which exceed it. At least one of the transport protocols used needs to have deadline awareness, which requires a moving average of RTTs, current playback position, and timestamps of recently lost frames. This behaviour could be implemented within an intermediary layer or within the QUIC protocol.

Dependencies between frames also need to be considered: P-frames change visual information relative to a previously sent I-frame, so a `stale' I-frame which will not arrive at the application before the playback deadline may still need to be retransmitted to allow useful P-frames to work. Either QUIC or an intermediary layer needs to be aware of which QUIC packets contain specific I-frames and which P-frames rely on them for this behaviour to work. This is complicated further by the possibility that multiple QUIC packets may be required to accomodate a single I-frame, depending on the maximum packet size allowed.

A retransmission scheme for RTP has already been published as RFC 4588 \cite{RTP-retransmission-RFC}. While this document acknowledges the challenges of implementing deadline awareness, it also assumes that RTP will be running over UDP rather than a reliable, stream-oriented transport. Running RTP over QUIC does have the advantage of not needing to re-implement base acknowledgement and retransmission functions from scratch, but the reliable retransmission and buffering behaviours within QUIC will need modification for selective retransmission and deadline awareness to work. These alterations cannot be performed at an intermediary layer or within an RTP-based application, and will add more complexity to the QUIC specification.

\subsection{Semantic Differences}

Creating an RTP extension for QUIC is further complicated by a semantic mismatch between the two protocols: RTP uses datagrams to transmit frame data and timing information, usually sending a single RTP frame per datagram, while QUIC is a stream-based protocol which does not have distinct boundaries between items of data once they are removed from their QUIC payload frames. It is not possible to guarantee a complete frame will be extracted from the stream due to not knowing its exact length - retrieving and parsing segments of arbitrary size to determine if one or more complete frames are present would add needless complexity to an RTP-QUIC extension, especially since a new parser would need to be written for each codec type. A custom QUIC payload frame type which contains a length field could resolve this issue.

An endpoint using QUIC over an IP link will aim to have a QUIC packet size between 1472 and 1200 bytes to avoid fragmentation at the IP layer \cite{quic-transport-16}. While P-frames and B-frames in video can be transmitted within this limit without fragmentation, I-frames are typically much larger and will need to be sent in multiple QUIC payloads. These will either need to be reassembled within QUIC and passed to the application as a single, complete frame; reassembled within the application itself; or reassembled within an intermediary layer.

While the I-frame reassembly entirely within QUIC makes the extension easier to use for developers of applications using RTP, it does also add complexity to an already extensive specification, requiring QUIC developers to add even more features to their implementations of the protocol. Reassembling I-frames within the application minimises the changes required to QUIC, but requires additional effort from developers working with real-time applications. The third option of offering a pre-built intermediary layer to handle RTP frame reassembly and error correction is a minimally invasive compromise for both parties, requiring no significant additions to QUIC and placing fewer technical demands on developers who wish to use the extensions, however, QUIC and the application using the extension have no requirement to validate that this layer is active on both endpoints. Similar considerations need to be made with regards to error correction for RTP frames: error correction and reassembly do not have to take place in the same locations, but it would likely be more sensible to do error correction after reassembly since flaws could be missed while fragments are separated.

The disparities between RTP and QUIC in terms of semantics and reliability make creating an RTP extension to the protocol challenging. However, the flexibility of QUIC as a userspace protocol allows significant changes to its underlying loss recovery and stream buffering behaviours, meaning that it is possible to build a variant of QUIC suited to interactive media through use of selective retransmissions and custom payload frame types.


\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Literature Survey}

%present an overview of relevant previous work including articles, books, and existing software products. Critically evaluate the strengths and weaknesses of the previous work.

\subsection{Proposed Adjustments to QUIC}

Although QUIC is still in the process of IETF standardisation, there is academic interest in extending the protocol. The EPIQ workshop \cite{epiq}, hosted as part of ACM CoNEXT 2018, featured two papers which are directly relevant to this project: a discussion of the challenges of supporting real-time media in QUIC and a proposed set of extensions, QUIC-R, by Perkins and Ott \cite{Perkins2018}; and ClipStream, a version of QUIC featuring partially reliable streams by Palmer \textit{et al} \cite{Palmer2018}.

The paper by Perkins and Ott contains valuable background information about the evolution of video streaming technologies and their potential place in QUIC. RTP was historically used to stream media on less reliable networks from the mid-1990s, but applications using this protocol are complex due to the mechanisms required to mitigate the effects of packet loss and out-of-order arrival. DASH is less complex, providing media content in pre-encoded chunks through a series of HTTP \texttt{GET} requests; this approach has become more widely used as networks have increased in quality and demand has risen for unidirectional streaming (ie. the content being sent is not impacted by the actions of the receiver and therefore has more relaxed latency bounds). RTP remains the best option for interactive, real-time media where timeliness is a priority, and for streaming over less reliable networks.

Adapting a mapping of RTP onto TCP specified in RFC 4751 \cite{RTP-TCP-RFC} for use with QUIC is discussed, but deemed unacceptable for applications with strict latency bounds. This is due to problems with head-of-line blocking which are inherent in all standard TCP stacks: any packets received by a TCP socket with a sequence number greater than the one held by a lost packet cannot be accessed by the application until this lost packet is received. Even if content flows can be multiplexed within the application, all flows are blocked by instances of packet loss even for streams unrelated to the content within the lost packet. An individual stream within QUIC does not suffer head-of-line blocking due to loss on other streams within the connection due to streams being multiplexed over a UDP socket, but it does still encounter high latency due to loss within its own stream. This is a problem for real-time multimedia applications where content delivered on parallel streams may be require synchronisation, such as lip-synchronisation on video calls.

%Although real-time, interactive media applications can tolerate some loss, they cannot tolerate much delay; the guaranteed reliability behaviour of standard TCP and QUIC connections confers no benefit to applications with strict latency bounds.

The idea of marking some streams as either reliable, partially reliable, or unreliable was proposed in an IETF draft by Tiesel \textit{et al} \cite{Tiesel2017}.  [Need to read this more in-depth]

A separate draft by Lubashev \cite{Lubashev2018} further elaborates on selective retransmissions, using single octet gaps to notify the application of message boundaries and marking data written to the transport as transmittable or non-retransmittable using offset markers. This approach may work for real-time media through marking data sent before the most recently sent I-frame as being ineligible for retransmission, but this could still result in retransmission of frames which would arrive after their respective playback deadlines. I-frames could be sent at an increased frequency to minimise this issue, but this would impact performance due to applications having to process a large amount of image data more frequently as well as potentially having to retransmit larger frames more often.

An approach which is less generalised, but does not require extensive configuration at the application level is explored in the second paper presented at EPIQ by Palmer textit{et al} \cite{Palmer2018}. Their extensions to QUIC, named ClipStream, only allows I-frames to be sent reliably, while P-frames (and B-frames, if available) are always sent unreliably. This is an improvement on marking contiguous sections of data as retransmittable or non-retransmittable, but it assumes that resending P-frames and B-frames is always unnecessary; retransmitting these frames if they will arrive before the playback deadline would improve media quality with no significant disadvantages.

Previous attempts have been made to implement deadline awarness for partial reliability within reliable, stream-based transports. Work by McQuistin on TCP Hollywood \cite{McQuistin2016} [further explanation needed about deadline awareness, selective retransmissions, ]

As outlined in section 1, it is easier to modify behaviours in QUIC than TCP due to the former not requiring the authoring or distribution of kernel-level modifications. QUIC also suffers less from traffic being rejected or otherwise modified by middleboxes due to packets being almost entirely encrypted: only a few header fields remain visible as plaintext to determine QUIC header type and which scheme should be used for decryption. Using a similar approach to TCP Hollywood in terms of deadline awareness and selective retransmissions would be beneficial to this project, however, it should not be blindly copied: in contrast to an assertion made in the QUIC-R paper by Perkins and Ott, a study by Bhat \textit{et al} \cite{Bhat2017} showing degraded performance of DASH over QUIC compared to DASH over TCP suggests that extending the capabilities of QUIC is not as simple as directly replicating existing techniques seen in TCP.

[Provide analysis on proposed QUIC-R extensions]

Other papers to discuss:
\begin{itemize}
  \item Real-Time Mode for TCP \cite{Liang2002}: Modifying TCP in 2002, finds that loss recovery 
  behaviours improve quality of real-time playback

  \item RFC 4588: RTP Retransmission Payload Format: Details of a 2006 scheme used for 
  restransmitting RTP packets. Doesn't take semantic differences into account and designed for 
  applications with relaxed latency bounds.

  \item Implementing Real-Time Transport Services over an Ossified Network 
  \cite {McQuistin2016Ossification}: Confirms the idea that UDP as a substrate for transport 
  protocols is viable and likely to gain further popularity. Provides statistics on how likely it 
  is that UDP traffic will be blocked by a given network.
\end{itemize}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Proposed Approach}

%state how you propose to solve the software development problem. Show that your proposed approach is feasible, but identify any risks.

Same as above: will be converted from a list into a formal discussion instead.

\begin{enumerate}
  \item Create a simple application in C which creates RTP packets (correctly formatted in terms 
  of headers, but not sending meaningful media content) and sends them to a remote peer. First 
  write this as a unidirectional application, then modify it to send data and RTCP info from both 
  participants simultaneously (Probably three threads: one for sending data and RTCP reports, one 
  polling the two sockets for new RTP data and RTCP feedback, and one processing received data 
  and reports)

  \item Modify the previous application to send correctly encoded media data (eg. Elephant's 
  Dream) using an arbitrarily chosen codec (probably H.264, since this was mentioned in the TCP 
  Hollywood paper)

  \item Change the underlying transport from UDP to QUIC using a single stream for all media 
  content and a separate stream for RTCP operations, all sent using generic DATA QUIC frames. The 
  performance will be terrible due to HoL blocking, but it will be a chance to become familiar 
  with the chosen QUIC implementation (likely ngtcp2 - draft-15 compliant, familiar language, and 
  client/server/library roles) (Will need to build a shim layer here to identify and mitigate 
  semantic differences between QUIC and RTP (eg. reassembling I-frames))

  \item Implement partial reliability by modifying loss recovery mechanisms within QUIC, again 
  testing on a minimal two-stream application (possibly unidirectional at first to simplify 
  debugging). Make sure this works by dropping (eg.) 10\% of QUIC packets and checking that 
  packets which are not received by participant B are no longer queued at participant A.

  \item Create deadline awareness using sequence numbers and an average of observed RTTs over a 
  given time period (eg. moving average over the past 20 trips). This will likely be in the shim 
  layer initially with a message of some sort being sent to QUIC to mark useful packets in some 
  way (or, alternatively, drop all queued packets with sequence number < [XYZ] from the buffer 
  which QUIC uses for holding retransmissions)

  \item Improve deadline awareness to take RTP frame dependencies into account: if an I-frame has 
  a sequence number which would cause it to be dropped from the buffer, check if there are P-
  frames with a sequence number >= [XYZ] - drop if no, keep if yes. Test this in a similar way to 
  (4), checking that packet traces and traces from within QUIC show these beahviours. (this will 
  require looking into QUIC payloads and detecting which kind of video frames are contained 
  within them - implementing new QUIC frames for I- and P-frames may make this process more 
  efficient)

  \item Create multiple QUIC streams for media and RTCP content. Start with creating a stream for 
  every video frame initially, keeping track of how many streams currently exist each time one is 
  created. Introduce a limit on the number of streams that can be created - start at the maximum 
  number of streams observed earlier, and decrement it by reasonable intervals for subsequent 
  tests.
\end{enumerate}

Requires more explanation of evaluation stage - which metrics should be tested?

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Work Plan}

%show how you plan to organize your work, identifying intermediate deliverables and dates.

Date listed indicates when that stage begins.

\begin{itemize}
  \item January 2nd: Implement simple application in C which sends RTP packets containing dummy 
  data to peer.
  \item January 7th: Modify the application to send valid media data using H.264 codec.
  \item January 14th: Change underlying transport in application from UDP to QUIC, try to get all 
  content sent on a single stream initially. (possibly two: one stream for RTCP?)
  \item January 21st: Implement partial reliability by changing loss recovery and retransmission 
  behaviours within QUIC, test with 10\% packet loss in unidirectional traffic on localhost to 
  verify it works.
  \item February 4th: Create deadline awareness using a moving average in the shim layer tracking 
  the last 20 or so RTTs. Mark packets containing useful frames and remove packets containing 
  stale frames from retransmission buffers.
  \item February 18th: Improve deadline awareness to take frame dependencies into account - QUIC 
  packets containing a stale I-frame should still be retransmitted if there are live P-frames 
  which depend on it. (Could be potential complications if a P-frame is dependent on an I-frame 
  in another QUIC stream)
  \item February 25th: Initial testing: how does QoE vary with the number of QUIC streams created?
  \item March 4th: Further tests/buffer for overrun deadlines
  \item April 1st: Write paper
\end{itemize}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% it is fine to change the bibliography style if you want
\bibliographystyle{plain}
\bibliography{mprop}
\end{document}
